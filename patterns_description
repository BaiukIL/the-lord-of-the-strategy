Empire.

    Empire has "cities" (array of "City" objects) and "army" fields:
        Empire:
            - Cities:
                - Buildings
            - Army:
                - Units

========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to structure empires?
------------------------------------------------------------------------------------------------------------------------
    Think: The idea is that empires are almost similar due to game balance. Thus we have like "common empire" which
    contains basic game interface (see attached .png file "Empire hierarchy") and all specific races merely differ in
    rendering and in few unique methods. The concept of fabrics
    (and sound reason) obliges us to keep every race's line separately. Indeed, since player created orc empire
    all his objects must behave as orc ones. Thus, every object has to remember what race it is. It can be done in 2 ways:

     1. every class has "race" field. It means we have only one base class for every object essence (like empire, city,
     army, etc.). This way, to add unique behavior for elves wall, for instance, we have to make a lot of "if-race" in this method.

     2. every class inherits "race" class, so race is set at its name. It means we have many derived classes for every
     object essence (like elves_empire, orcs_empire, dwarfs_empire, elf_city...). However, to add unique behavior for elves wall,
     for instance, we just have to add a new method in elves_wall class.

    First case looks like god-object with too many methods (orcs_army shouldn't have increase_elves_units_speed method). It also
    makes code tough to read.
    The other case seems to be copy-and-paste problem, like:

        class ElfEmpire(Empire, races.Elves):
            def __init__(self):
                super().__init__()
                self.army = army.ElfArmy(self)

            def establish_city(self, name):
                if name not in self.cities:
                    self.cities[name] = city.ElfCity(name, self)
                else:
                    raise KeyError("City {} has already exists in {} cities".format(name, self.__class__.__name__))


        class OrcEmpire(Empire, races.Orcs):
            def __init__(self):
                super().__init__()
                self.army = army.OrcArmy(self)

            def establish_city(self, name):
                if name not in self.cities:
                    self.cities[name] = city.OrcCity(name, self)
                else:
                    raise KeyError("City {} has already exists in {} cities".format(name, self.__class__.__name__))


        class DwarfEmpire(Empire, races.Dwarfs):
            def __init__(self):
                super().__init__()
                self.army = army.DwarfArmy(self)

            def establish_city(self, name):
                if name not in self.cities:
                    self.cities[name] = city.DwarfCity(name, self)
                else:
                    raise KeyError("City {} has already exists in {} cities".format(name, self.__class__.__name__))

    so our program will bush out very quickly.

    However, there's no other choice to structure empire lines in accordance with races (bridge pattern
    resolves into the first problem of storing object as a field; decorator pattern resolves into
    the second case).
------------------------------------------------------------------------------------------------------------------------
    Solution: I've decided to choose the last solution (even though it leads to copy-and-paste problem) because
    it makes code more explicit and it is unnecessary to rewrite previous code in case of addition a new race into the game.
    In this case, to structure empires, we can make an (ABSTRACT) FACTORY of empires - EmpireFactory.
    When players wants to create empire of a specific race,he asks it from the factory.
    It allows us not to worry about compatibility of empire's objects. Also we can interact
    with empires, cities, armies without binding to its implementations (because they have abstract base classes)*.

    * There is dynamic typification in python, so we can interact with objects throughout its base class methods without using
    factory which returns base class object. However, it does not mean factory is useless: it allows us to
    control object's creation.
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

City.
    City has "buildings" field (array of "Building"). It has nothing interesting so far.
    It's important to say, that even though elf, orc and dwarf city do not differ in interface

Building.
    What is about the very buildings? Every building is a complex object which is supposed to have a big number of args
    during construction.
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to construct buildings?
------------------------------------------------------------------------------------------------------------------------
    Think: So far building can be barrack, mine or wall. It is clear, for example, that elves', dwarfs' or orcs' mines
    are pretty similar. It suggests that we can build ones using similar functions (these objects can be complex, so using
    step-by-step functions can be much useful than using a single stacked constructor).
------------------------------------------------------------------------------------------------------------------------
    Solution: Use BUILDER pattern. Every type of building will have BUILDER and DIRECTOR classes managing its construction.
    To create object we will use:
        director = ...Director()
        builder = ...Builder()
        director.create_...(builder)
    It seems to be good idea to use this pattern, for we can easily manage with building creation and hide huge
    constructor from user.
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to structure buildings hierarchy?
------------------------------------------------------------------------------------------------------------------------
    Think: -- structural patterns --
------------------------------------------------------------------------------------------------------------------------
    Solution: -- structural patterns -- (bridge???)
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

    Consider Building closer. It has health (health is also incident to Unit - that's why
    health is separate interface) and city fields. Last one is responsible for connection with master city (it is wide
    spread construction in the program, so I use it often. For example, it can connect army and city with empire.
    I guess some behavioral pattern deal with it more successfully in the future).

    1. Barrack is an ABSTRACT FACTORY of units. The only way units can be created is to be produced from barrack. Elf barrack
    produces Elf units, Dwarf barrack - Dwarf units and etc.
    2. Mine produces resources for designing building and creating units.
    3. Wall protects city from enemies.

Unit.
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to build units hierarchy?
------------------------------------------------------------------------------------------------------------------------
    Think: -- structural patterns --
------------------------------------------------------------------------------------------------------------------------
    Solution: -- structural patterns -- (bridge???)
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

Army.
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to structure army troops hierarchy?
------------------------------------------------------------------------------------------------------------------------
    Think: -- structural patterns --
------------------------------------------------------------------------------------------------------------------------
    Solution: -- structural patterns -- (composite???)
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Other words.
1. In some harmless cases I use exceptions which are not supposed to be caught. It looks like self-destruction
anti-pattern, but I will remove such things in the future. Now it's rather useful to find out every, even little, mistake.
2. There're many empty methods and classes in the game. They will have body onto next stages of the project.
3. Many objects have already have some hierarchy. However, it's about structural patterns, so these places might be redone next.
4. By the moment I wrote this code for the first review, I've realised that first way (mentioned on 26th line)
seemed to be better than chosen one (because it does not need as many copy-and-paste code as second does).

Questions:
1. Is first solution (line 26) better than this one?
2. Is it OK to do all the tests in one file or they should be located apart?
