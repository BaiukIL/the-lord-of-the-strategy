Empire.

    Empire has "cities" (array of "City" objects) and "army" fields:
        Empire:
            - Cities:
                - Buildings
            - Army:
                - Units

========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to structure empires?
------------------------------------------------------------------------------------------------------------------------
    Think: The idea is that empires are almost similar due to game balance. Thus we have kind of "common empire" which
    contains basic game interface (see attached .png file "Empire hierarchy") and all specific races merely differ in
    rendering and in few unique methods. The concept of fabrics
    (and sound reason) obliges us to keep every race's line separately. Indeed, since player created orc empire
    all his objects must behave as orc ones. Thus, every object has to remember what race it is. It can be done in 2 ways:

     1. every class has "race" field. It means we have only one base class for every object essence (like empire, city,
     army, etc.). This way, to add unique behavior for elves wall, for instance, we have to make a lot of "if-race" in this method.

     2. every class inherits "race" class, so race is set at its name. It means we have many derived classes for every
     object essence (like elves_empire, orcs_empire, dwarfs_empire, elf_city...). However, to add unique behavior for elves wall,
     for instance, we just have to add a new method in elves_wall class.

    First case looks like god-object with too many methods (orcs_army shouldn't have increase_elves_units_speed method). It also
    makes code tough to read.
    The other case seems to be copy-and-paste problem, like:

        class ElfEmpire(Empire, races.Elves):
            def __init__(self):
                super().__init__()
                self.army = army.ElfArmy(self)

            def establish_city(self, name):
                if name not in self.cities:
                    self.cities[name] = city.ElfCity(name, self)
                else:
                    raise KeyError("City {} has already exists in {} cities".format(name, self.__class__.__name__))


        class OrcEmpire(Empire, races.Orcs):
            def __init__(self):
                super().__init__()
                self.army = army.OrcArmy(self)

            def establish_city(self, name):
                if name not in self.cities:
                    self.cities[name] = city.OrcCity(name, self)
                else:
                    raise KeyError("City {} has already exists in {} cities".format(name, self.__class__.__name__))


        class DwarfEmpire(Empire, races.Dwarfs):
            def __init__(self):
                super().__init__()
                self.army = army.DwarfArmy(self)

            def establish_city(self, name):
                if name not in self.cities:
                    self.cities[name] = city.DwarfCity(name, self)
                else:
                    raise KeyError("City {} has already exists in {} cities".format(name, self.__class__.__name__))

    so our program will bush out very quickly.

    However, there's no other choice to structure empire lines in accordance with races (bridge pattern
    resolves into the first problem of storing object as a field; decorator pattern resolves into
    the second case).
------------------------------------------------------------------------------------------------------------------------
    Solution: I've decided to choose the first one because
    it makes code more explicit and it is unnecessary to rewrite previous code in case of addition a new race into the game.
    In this case, to structure empires, we can make an (ABSTRACT) FACTORY of empires - EmpireFactory.
    When player wants to create empire of a specific race, he asks it from the factory.
    It allows us not to worry about compatibility of empire's objects. Also we can interact
    with empires, cities, armies without binding to its implementations (because they have abstract base classes)*.

    * There is dynamic typification in python, so we can interact with objects throughout its base class methods without using
    factory which returns base class object. However, it does not mean factory is useless: it allows us to
    control object's creation.
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

City.
    City has "buildings" field (array of "Building"). It has nothing interesting so far.
    It's important to say, that even though elf, orc and dwarf city do not differ in interface

Building.
    What is about the very buildings? Every building is a complex object which is supposed to have a big number of args
    during construction.
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to construct buildings?
------------------------------------------------------------------------------------------------------------------------
    Think: So far building can be barrack, mine or wall. It is clear, for example, that elves', dwarfs' or orcs' mines
    are pretty similar. It suggests that we can build ones using similar functions (these objects can be complex, so using
    step-by-step functions can be much useful than using a single stacked constructor).
------------------------------------------------------------------------------------------------------------------------
    Solution: Use BUILDER pattern. Every type of building will have BUILDER and DIRECTOR classes managing its construction.
    To create object we will use:
        director = ...Director()
        builder = ...Builder()
        director.create_...(builder)
    It seems to be good idea to use this pattern, for we can easily manage with building creation and hide huge
    constructor from user.
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to structure buildings hierarchy?
------------------------------------------------------------------------------------------------------------------------
    Think: -- structural patterns --
------------------------------------------------------------------------------------------------------------------------
    Solution: -- structural patterns -- (bridge???)
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

    Consider Building closer. It has health (health is also incident to Unit - that's why
    health is separate interface) and city fields. Last one is responsible for connection with master city (it is wide
    spread construction in the program, so I use it often. For example, it can connect army and city with empire.
    I guess some behavioral pattern deal with it more successfully in the future).

    1. Barrack is an ABSTRACT FACTORY of units. The only way units can be created is to be produced from barrack. Elf barrack
    produces Elf units, Dwarf barrack - Dwarf units and etc.
    2. Mine produces resources for designing building and creating units.
    3. Wall protects city from enemies.

Unit.
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to build units hierarchy?
------------------------------------------------------------------------------------------------------------------------
    Think: -- structural patterns --
------------------------------------------------------------------------------------------------------------------------
    Solution: -- structural patterns -- (bridge???)
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

Army.
========================================================================================================================
------------------------------------------------------------------------------------------------------------------------
    Problem: How to structure army troops hierarchy?
------------------------------------------------------------------------------------------------------------------------
    Think: -- structural patterns --
------------------------------------------------------------------------------------------------------------------------
    Solution: -- structural patterns -- (composite???)
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================

Bridge.
It comes into use when we want to separate abstraction and realization. All connections are on the abstraction level and I want
realizations will be able to change in the future (for example, if I want to rewrite game onto another framework).
However, it is not good idea to make "realization" field for every entity, for in this case it cannot be used in pygame
object structures (like pygame.sprite.Group), which are very useful. It is impossible because
these structures can only deal with objects derived from pygame.sprite.Sprite. Since my abstractions are not derived from
this class they cannot be used in such structures. Thus bridge pattern as composition of entities is not suitable, but what
about using inheritance instead of composition? The idea of bridge pattern will be preserved (I still can set abstraction and
realization apart using another inheritance), and it allows us to use pygame object structures because every object IS
DERIVED from pygame.sprite.Sprite.
How do I do this inheritance? There is a GameObject class which is inherited from pygame.sprite.Sprite and is responsible
for connection between abstraction and realization. It is the only place I have to track any problems with this connection.
All game entities which are supposed to have realization are just inherited from this one.
To sum up, we changed composition in bridge pattern (because it is impossible in our case) to inheritance saving the
idea of bridge pattern.


Other words.
1. In some harmless cases I use exceptions which are not supposed to be caught. It looks like self-destruction
anti-pattern, but I will remove such things in the future. Now it's rather useful to find out every, even little, mistake.
2. There're many empty methods and classes in the game. They will have body onto next stages of the project.
3. Many objects have already have some hierarchy. However, it's about structural patterns, so these places might be redone next.
4. By the moment I wrote this code for the first review, I've realised that first way (mentioned on 26th line)
seemed to be better than chosen one (because it does not need as many copy-and-paste code as second does).

Think:
1. city.py : 13 : self.fabric = fabric.Manufacture().create_fabric(self)
    Is it ok to delegate buildings addition to fabric? It makes these modules strongly-connected what is not good.
    However, if we make building addition city's duty, we have to wrap all fabric's calls in functions
(which will add factory-builded building to city._buildings). It makes code bigger.
    The third way is to use Observer pattern for such cases. but... is it justified to use Observer which connects
just two objects? There is no problem if we uses Observer to inform city about building events. (by the way thus
we get rid of "city" in constructor (otherwise what is the sense in using Observer?) so building does not know
what city it belongs to). Problem occurs when we creates units this way. How to inform ARMY about UNIT creation???

2. How to be with function annotations? It's good idea to use them. However, functions usually returns objects
from other modules, so to make annotation it's necessary to import modules of such modules which makes program
strongly-connected (sometimes it even leads to mutual import)
